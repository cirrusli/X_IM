package x

import (
	"X_IM/pkg/logger"
	"X_IM/pkg/wire/common"
	"X_IM/pkg/wire/pkt"
	"google.golang.org/protobuf/proto"
	"sync"
)

// Session is read-only
type Session interface {
	GetChannelID() string
	GetGateID() string
	GetAccount() string
	GetZone() string
	GetIsp() string
	GetRemoteIP() string
	GetDevice() string
	GetApp() string
	GetTags() []string
}

type Context interface {
	Dispatcher
	SessionStorage
	Header() *pkt.Header
	ReadBody(val proto.Message) error
	Session() Session
	RespWithError(status pkt.Status, err error) error
	// Resp 给发送方回复一条消息
	Resp(status pkt.Status, body proto.Message) error
	// Dispatch 给指定的接收方发送一条消息
	Dispatch(body proto.Message, recvs ...*Location) error
	Next()
}

// HandlerFunc to use handler
type HandlerFunc func(Context)

type HandlersChain []HandlerFunc

// ContextImpl is the most important part of X_IM, it carries request scope
type ContextImpl struct {
	sync.Mutex
	Dispatcher
	SessionStorage

	handlers HandlersChain
	// index of current handler
	index   int
	request *pkt.LogicPkt
	session Session
}

// BuildContext 创建一个空的Context对象
func BuildContext() Context {
	return &ContextImpl{}
}

// Next 执行下一个handler
func (c *ContextImpl) Next() {
	if c.index >= len(c.handlers) {
		//已超过已有的handler数量
		return
	}
	f := c.handlers[c.index]
	c.index++
	if f == nil {
		logger.Warn("arrived unknown HandlerFunc: nil handler")
		return
	}
	f(c)
	//todo is that necessary?
	//c.Next()
}

func (c *ContextImpl) reset() {
	c.request = nil
	c.index = 0
	c.handlers = nil
	c.session = nil
}

func (c *ContextImpl) Header() *pkt.Header {
	return &c.request.Header
}

func (c *ContextImpl) ReadBody(val proto.Message) error {
	return c.request.ReadBody(val)
}

// Session 从request中获取session，如果没有则创建一个
func (c *ContextImpl) Session() Session {
	if c.session == nil {
		server, _ := c.request.GetMeta(common.MetaDestServer)
		c.session = &pkt.Session{
			ChannelID: c.request.ChannelID,
			GateID:    server.(string),
			Tags:      []string{"AutoGenerated"},
		}
	}
	return c.session
}

func (c *ContextImpl) RespWithError(status pkt.Status, err error) error {
	return c.Resp(status, &pkt.ErrorResp{Message: err.Error()})
}

// Resp 复制request的header，然后修改flag为response，然后发送
func (c *ContextImpl) Resp(status pkt.Status, body proto.Message) error {
	packet := pkt.NewFrom(&c.request.Header)
	packet.Status = status
	packet.WriteBody(body)
	packet.Flag = pkt.Flag_Response
	logger.Infof("<-- Resp to %s command:%s  status: %v body: %s",
		c.Session().GetAccount(), &c.request.Header, status, body)

	err := c.Push(c.Session().GetGateID(),
		[]string{c.Session().GetChannelID()}, packet)
	if err != nil {
		logger.Error(err)
	}
	return err
}

// Dispatch 采用合并转发
func (c *ContextImpl) Dispatch(body proto.Message, recvs ...*Location) error {
	if len(recvs) == 0 {
		return nil
	}
	packet := pkt.NewFrom(&c.request.Header)
	packet.Flag = pkt.Flag_Push
	packet.WriteBody(body)

	logger.Debugf("<-- Dispatch to %d users command:%s",
		len(recvs), &c.request.Header)

	group := make(map[string][]string)
	for _, recv := range recvs {
		//不给自己发
		if recv.ChannelID == c.Session().GetChannelID() {
			continue
		}
		//按照网关分组
		if _, ok := group[recv.GateID]; !ok {
			group[recv.GateID] = make([]string, 0)
		}
		group[recv.GateID] = append(group[recv.GateID], recv.ChannelID)
	}
	//分组发送
	for gateway, IDs := range group {
		err := c.Push(gateway, IDs, packet)
		if err != nil {
			logger.Error(err)
			return err
		}
	}
	return nil
}
